---------------------------**NOTES**---------------------------

This is a notes file to keep track of progress and changes that
must be made or bugs that were resolved. Documentation is also
included here.

<!-- Author: Obada -->
*Current code base version* -> *Doesn't compile all files*

1. *Server* (IN PROGRESS) ~ Mutasem | mmajid-m
- socket -> initialize server varaibles -> setsockopt -> bind -> listen -> accept (NOT DONE)
- Redo Server::run() function for a cleaner/clearer code and use poll() (NOT DONE)
- Rename variables in Server.hpp to more meaningful names (NOT DONE)

2. *Parsing* (IN PROGRESS) ~ AbdulAziz | ael-masr
- Parse command line (NOT DONE)
- Call appropriate commands when used (NOT DONE)
- Call appropriate error codes when applicable (NOT DONE)
- Handle all CAP commands (CAP LS, CAP REQ, CAP ACK, CAP END) (NOT DONE)

3. *Commands* (DONE) ~ Obada | 0bada1
- USER (DONE) ✅
- NICK (DONE) ✅
- JOIN (DONE) ✅
. Usage:
JOIN #<channel>
JOIN &<channel>
- PART (DONE) ✅
- PRIVMSG (DONE) ✅
. Usage:
PRIVMSG <user> <msg>
PRIVMSG #<channel> <msg>
- NOTICE (DONE) ✅
- KICK (DONE) ✅
- INVITE (DONE) ✅
- TOPIC (DONE) ✅
- MODE (DONE) ✅
Options:
· i: Set/remove Invite-only channel (DONE) ✅
· t: Set/remove the restrictions of the TOPIC command to channel operators (DONE) ✅
· k: Set/remove the channel key (password) (DONE) ✅
· o: Give/take channel operator privilege (DONE) ✅
· l: Set/remove the user limit to channel (DONE) ✅

_______________________________________________________________

***RFC 1459 NOTES***
1.2 Clients
* Description
- Anything that connects to a server apart from a server
* Restrictions (See RFC 2812 section 5.1)
- A client nickname shall be only up to 9 characters

1.3 Channels
* Description
- A channel is a group that is created when the first user joins and deleted when the last user leaves
- 2 types of channels exist:
. '#' channel
. '&' channel
* Channel name resrictions:
- Channel name can be up to 200 characters
- Channel name must begin with '&' or '#'
- Channel name may not contain spaces, comas or ctrl G (^G or ASCII 7)
- Maximum of 10 joined channels at once per user
	1.3.1 Channel Operators
	* Description
	- A channel operator is the owner of a channel and is identified by a '@' prefix sign in their name in the channel only
	* Operations allowed by channel operators
	- KICK -> Eject client from channel
	- MODE -> Change channel mode
	- INVITE -> Invite a client to an invite only channel (+i)
	- TOPIC -> Change the channel topic in a +t channel

2. 

***RFC 2810 NOTES***

***RFC 2812 NOTES***















TRASH CODE
				for (std::vector<Channel>::iterator it = Server::channels_.begin(); it != Server::channels_.end(); it++)
				{
					it_u = it->user_index(Server::current_fd);
					it_o = it->operator_index(Server::current_fd);
					if (it_u != it->get_users().end())
						it->get_users().erase(it_u);
					if (it_o != it->get_operator_list().end())
					{
						it->get_operator_list().erase(it_o);
						it_o = it->get_users().begin();
						if (it_o != it->get_users().end() && it->get_operator_list().size() == 0)
							it->get_operator_list().push_back(*it_o);
					}
					it_i = it->invite_index(Server::current_fd);
					if (it_i != it->get_invite_list().end())
						it->get_invite_list().erase(it_i);
				}









				                for (size_t k = 0; k < Server::channels_.size(); k++)
				{
					user_index = Server::channels_[k].user_index(Server::current_fd);
					operator_index = Server::channels_[k].operator_index(Server::current_fd);
					// cout << "SEGFAULT: " << user_index << endl;
					// Utils::printChannelList();
					// cout << "User " << "0" << " " << Server::channels_[0].get_users()[0].getNickname() << endl;
					// cout << Server::channels_[k].find_user(Server::channels_[k].get_users(), Server::channels_[k].get_users()[user_index]) << endl;					if (user_index < Server::channels_[k].get_users().size() && static_cast<int>(user_index) != -1)
						Server::channels_[k].get_users().erase(Server::channels_[k].get_users().begin() + user_index);
					if (operator_index != Server::channels_[k].get_operator_list().size())
					{
						Server::channels_[k].get_operator_list().erase(Server::channels_[k].get_operator_list().begin() + operator_index);
						it_o = Server::channels_[k].get_users().begin();
						if (operator_index != Server::channels_[k].get_users().size() && Server::channels_[k].get_operator_list().size() == 0)
							Server::channels_[k].get_operator_list().push_back(*it_o);
					}
					invite_index = Server::channels_[k].invite_index(Server::current_fd);
					if (invite_index != Server::channels_[k].get_invite_list().size())
						Server::channels_[k].get_invite_list().erase(Server::channels_[k].get_invite_list().begin() + invite_index);
				}
















				for (std::vector<Channel>::iterator it = Server::channels_.begin(); it != Server::channels_.end(); it++)
				{
					it_u = it->user_index(Server::current_fd);
					it_o = it->operator_index(Server::current_fd);
					if (it_u != it->get_users().end())
						it->get_users().erase(it_u);
					if (it_o != it->get_operator_list().end())
					{
						it->get_operator_list().erase(it_o);
						it_o = it->get_users().begin();
						if (it_o != it->get_users().end() && it->get_operator_list().size() == 0)
							it->get_operator_list().push_back(*it_o);
					}
					it_i = it->invite_index(Server::current_fd);
					if (it_i != it->get_invite_list().end())
						it->get_invite_list().erase(it_i);
					t_it = it;
					if (it->get_users().size() == 0)
					{
						cout << "DELETING CHANNEL" << endl;
						t_it->removeChannel(t_it->get_channel_name());
					}
				}